From 8733903e6960fcd4bca1be8cc5d583c865dc49f8 Mon Sep 17 00:00:00 2001
From: bigfoot547 <bigfoot@figboot.dev>
Date: Sat, 26 Mar 2022 15:24:44 -0500
Subject: [PATCH] Add bundled java runtime functionality


diff --git a/src/main/java/com/mojang/launcher/Launcher.java b/src/main/java/com/mojang/launcher/Launcher.java
index f79a4b6..100ab0f 100644
--- a/src/main/java/com/mojang/launcher/Launcher.java
+++ b/src/main/java/com/mojang/launcher/Launcher.java
@@ -9,6 +9,10 @@ import java.net.PasswordAuthentication;
 import java.net.Proxy;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+
+import dev.figboot.olauncher.OLauncherConstants;
+import dev.figboot.olauncher.launcher.runtime.JavaRuntimeManager;
+import lombok.Getter;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -24,6 +28,8 @@ public class Launcher {
     private final ReleaseTypeFactory releaseTypeFactory;
     private final int launcherFormatVersion;
 
+    @Getter private final JavaRuntimeManager jreManager; // olauncher - add java runtime manager
+
     public Launcher(UserInterface var1, File var2, Proxy var3, PasswordAuthentication var4, VersionManager var5, Agent var6, ReleaseTypeFactory var7, int var8) {
         this.downloaderExecutorService = new ExceptionalThreadPoolExecutor(16, 16, 30L, TimeUnit.SECONDS);
         this.ui = var1;
@@ -35,6 +41,8 @@ public class Launcher {
         this.releaseTypeFactory = var7;
         this.launcherFormatVersion = var8;
         this.downloaderExecutorService.allowCoreThreadTimeOut(true);
+
+        this.jreManager = new JavaRuntimeManager(OLauncherConstants.JRE_MANIFEST_URL, var3, var2); // olauncher - add java runtime manager
     }
 
     public ReleaseTypeFactory getReleaseTypeFactory() {
diff --git a/src/main/java/com/mojang/launcher/game/runner/AbstractGameRunner.java b/src/main/java/com/mojang/launcher/game/runner/AbstractGameRunner.java
index f3546fc..cd37a5b 100644
--- a/src/main/java/com/mojang/launcher/game/runner/AbstractGameRunner.java
+++ b/src/main/java/com/mojang/launcher/game/runner/AbstractGameRunner.java
@@ -10,9 +10,16 @@ import com.mojang.launcher.updater.download.DownloadListener;
 import com.mojang.launcher.updater.download.Downloadable;
 import com.mojang.launcher.versions.CompleteVersion;
 import java.io.IOException;
+import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
+
+import dev.figboot.olauncher.launcher.runtime.JavaRuntimeManager;
+import dev.figboot.olauncher.launcher.runtime.RuntimesManifest;
+import dev.figboot.olauncher.launcher.runtime.file.RuntimeFileList;
+import lombok.AccessLevel;
+import lombok.Getter;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -24,6 +31,8 @@ public abstract class AbstractGameRunner implements GameRunner, DownloadListener
     private GameInstanceStatus status;
     private final List<GameRunnerListener> listeners;
 
+    @Getter(AccessLevel.PROTECTED) private Path bundledRuntimeDir; // olauncher - add bundled runtime directory
+
     public AbstractGameRunner() {
         this.status = GameInstanceStatus.IDLE;
         this.listeners = Lists.newArrayList();
@@ -48,7 +57,7 @@ public abstract class AbstractGameRunner implements GameRunner, DownloadListener
         return this.status;
     }
 
-    public void playGame(VersionSyncInfo var1) {
+    public void playGame(VersionSyncInfo var1, boolean bundledRuntime) { // olauncher - add bundledRuntime argument
         synchronized(this.lock) {
             if (this.getStatus() != GameInstanceStatus.IDLE) {
                 LOGGER.warn("Tried to play game but game is already starting!");
@@ -109,12 +118,88 @@ public abstract class AbstractGameRunner implements GameRunner, DownloadListener
                     }
 
                     this.setStatus(GameInstanceStatus.DOWNLOADING);
+
+                    // olauncher start - handle java runtime setting
+                    if (bundledRuntime) {
+                        try {
+                            ensureRuntime();
+                        } catch (IOException ex) {
+                            LOGGER.error("I/O error setting up bundled java runtime", ex);
+                            setStatus(GameInstanceStatus.IDLE);
+                            return;
+                        } catch (RuntimeException ex) {
+                            LOGGER.error("Error setting up bundled java runtime", ex);
+                            setStatus(GameInstanceStatus.IDLE);
+                            return;
+                        }
+                    }
+                    // olauncher end
+
                     this.downloadRequiredFiles(var1);
                 }
             }
         }
     }
 
+    // olauncher start - java runtime functions
+    private void ensureRuntime() throws IOException {
+        JavaRuntimeManager jreManager = getLauncher().getJreManager();
+        String component = version.getJavaVersion().getComponent();
+        List<RuntimesManifest.Runtime> runtimes = jreManager.getRuntimes(component);
+
+        if (runtimes.size() == 0) {
+            throw new RuntimeException("There are no supported java runtimes. You choose one manually.");
+        }
+
+        if (runtimes.size() > 1) {
+            LOGGER.warn("More than one java runtime is available, choosing one at random:");
+            for (RuntimesManifest.Runtime runtime : runtimes) {
+                LOGGER.warn("- " + runtime.getVersion().getName() + " (Released at " + runtime.getVersion().getReleased().toString() + ")");
+            }
+        }
+
+        RuntimesManifest.Runtime runtime = runtimes.get(0);
+        if (!jreManager.shouldDownloadRuntime(component, runtime)) {
+            bundledRuntimeDir = jreManager.getJavaExecutable(component);
+            return; // the runtime is up-to-date! :)
+        }
+
+        LOGGER.info("Need to download java runtime '" + runtime.getVersion().getName() + "' (Released at " + runtime.getVersion().getReleased().toString() + ")");
+
+        jreManager.deleteRuntime(component);
+        RuntimeFileList files = jreManager.downloadFileList(component, runtime);
+        jreManager.preDownloadRuntime(component, runtime, files);
+        bundledRuntimeDir = jreManager.getJavaExecutable(component);
+
+        // Download the runtime
+        DownloadJob job = new DownloadJob("Java Runtime", false, new DownloadListener() {
+            @Override
+            public void onDownloadJobFinished(DownloadJob var1) {
+                afterDownloadRuntime(jreManager, component, runtime);
+                AbstractGameRunner.this.onDownloadJobFinished(var1);
+            }
+
+            @Override
+            public void onDownloadJobProgressChanged(DownloadJob var1) {
+                updateProgressBar();
+            }
+        });
+
+        addJob(job);
+        jreManager.downloadRuntime(job, component, files);
+        job.startDownloading(getLauncher().getDownloaderExecutorService());
+    }
+
+    private void afterDownloadRuntime(JavaRuntimeManager jreManager, String component, RuntimesManifest.Runtime runtime) {
+        try {
+            jreManager.postDownloadRuntime(component, runtime);
+        } catch (IOException ex) {
+            LOGGER.error("Error writing java runtime version description, the runtime may be redownloaded", ex);
+        }
+    }
+
+    // olauncher end
+
     protected void downloadRequiredFiles(VersionSyncInfo var1) {
         try {
             DownloadJob var2 = new DownloadJob("Version & Libraries", false, this);
diff --git a/src/main/java/com/mojang/launcher/game/runner/GameRunner.java b/src/main/java/com/mojang/launcher/game/runner/GameRunner.java
index 7bd69c9..5d5fa85 100644
--- a/src/main/java/com/mojang/launcher/game/runner/GameRunner.java
+++ b/src/main/java/com/mojang/launcher/game/runner/GameRunner.java
@@ -7,7 +7,7 @@ import com.mojang.launcher.updater.download.DownloadJob;
 public interface GameRunner {
     GameInstanceStatus getStatus();
 
-    void playGame(VersionSyncInfo var1);
+    void playGame(VersionSyncInfo var1, boolean bundledRuntime); // olauncher - add bundledRuntime argument
 
     boolean hasRemainingJobs();
 
diff --git a/src/main/java/com/mojang/launcher/versions/CompleteVersion.java b/src/main/java/com/mojang/launcher/versions/CompleteVersion.java
index afa4dd4..c05c7f7 100644
--- a/src/main/java/com/mojang/launcher/versions/CompleteVersion.java
+++ b/src/main/java/com/mojang/launcher/versions/CompleteVersion.java
@@ -1,5 +1,7 @@
 package com.mojang.launcher.versions;
 
+import dev.figboot.olauncher.launcher.JavaVersionInfo;
+
 import java.util.Date;
 
 public interface CompleteVersion extends Version {
@@ -20,4 +22,7 @@ public interface CompleteVersion extends Version {
     boolean isSynced();
 
     void setSynced(boolean var1);
+
+    // olauncher - JavaVersion getter
+    JavaVersionInfo getJavaVersion();
 }
diff --git a/src/main/java/dev/figboot/olauncher/OLauncherConstants.java b/src/main/java/dev/figboot/olauncher/OLauncherConstants.java
index f1e3ac7..7a1909a 100644
--- a/src/main/java/dev/figboot/olauncher/OLauncherConstants.java
+++ b/src/main/java/dev/figboot/olauncher/OLauncherConstants.java
@@ -1,7 +1,10 @@
 package dev.figboot.olauncher;
 
+import java.net.URL;
 import java.util.UUID;
 
+import static net.minecraft.launcher.LauncherConstants.constantURL;
+
 public final class OLauncherConstants {
     private OLauncherConstants() { }
 
@@ -10,4 +13,6 @@ public final class OLauncherConstants {
     public static final String APP_SCOPES = "XboxLive.signin offline_access";
     public static final int REDIR_URI_PORT = 6183;
     public static final String REDIR_URI = "http://localhost:" + REDIR_URI_PORT;
+
+    public static final URL JRE_MANIFEST_URL = constantURL("https://launchermeta.mojang.com/v1/products/java-runtime/2ec0cc96c44e5a76b9c8b7c39df7210883d12871/all.json");
 }
diff --git a/src/main/java/dev/figboot/olauncher/launcher/JavaVersionInfo.java b/src/main/java/dev/figboot/olauncher/launcher/JavaVersionInfo.java
new file mode 100644
index 0000000..81da113
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/launcher/JavaVersionInfo.java
@@ -0,0 +1,23 @@
+package dev.figboot.olauncher.launcher;
+
+import lombok.Getter;
+
+public class JavaVersionInfo {
+    public static final JavaVersionInfo DEFAULT;
+
+    @Getter private String component;
+    @Getter private int majorVersion;
+
+    public JavaVersionInfo() { }
+
+    public JavaVersionInfo(JavaVersionInfo other) {
+        this.component = other.component;
+        this.majorVersion = other.majorVersion;
+    }
+
+    static {
+        DEFAULT = new JavaVersionInfo();
+        DEFAULT.component = "jre-legacy";
+        DEFAULT.majorVersion = 8;
+    }
+}
diff --git a/src/main/java/dev/figboot/olauncher/launcher/runtime/JavaRuntimeManager.java b/src/main/java/dev/figboot/olauncher/launcher/runtime/JavaRuntimeManager.java
new file mode 100644
index 0000000..551c252
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/launcher/runtime/JavaRuntimeManager.java
@@ -0,0 +1,228 @@
+package dev.figboot.olauncher.launcher.runtime;
+
+import com.google.common.reflect.TypeToken;
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.mojang.launcher.Http;
+import com.mojang.launcher.OperatingSystem;
+import com.mojang.launcher.updater.ExceptionalThreadPoolExecutor;
+import com.mojang.launcher.updater.download.DownloadJob;
+import com.mojang.launcher.updater.download.Downloadable;
+import dev.figboot.olauncher.launcher.runtime.download.RuntimeFileDownloadable;
+import dev.figboot.olauncher.launcher.runtime.file.RuntimeFile;
+import dev.figboot.olauncher.launcher.runtime.file.RuntimeFileFile;
+import dev.figboot.olauncher.launcher.runtime.file.RuntimeFileList;
+import dev.figboot.olauncher.util.DeletingFileVisitor;
+import dev.figboot.olauncher.util.InstantTypeAdapter;
+import dev.figboot.olauncher.util.runtime.RuntimeFileDeserializer;
+import lombok.Getter;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.io.BufferedReader;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.math.BigInteger;
+import java.net.HttpURLConnection;
+import java.net.Proxy;
+import java.net.URL;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.security.DigestInputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.time.Instant;
+import java.util.*;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+public class JavaRuntimeManager {
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    private boolean refreshing;
+    private final Object refreshingLock = new Object();
+
+    private final URL manifestUrl;
+    private final Proxy proxy;
+
+    private final Path runtimesDirectory;
+    private final Path platformDirectory;
+    private final Gson gson;
+
+    private final String jrePlatformName;
+    @Getter private final ThreadPoolExecutor executorService;
+    private Map<String, Map<String, List<RuntimesManifest.Runtime>>> manifest;
+
+    public JavaRuntimeManager(URL manifestUrl, Proxy proxy, File workDir) {
+        refreshing = false;
+        this.manifestUrl = manifestUrl;
+        this.proxy = proxy;
+
+        runtimesDirectory = workDir.toPath().resolve("olruntime");
+        gson = new GsonBuilder()
+                .registerTypeAdapter(Instant.class, new InstantTypeAdapter())
+                .registerTypeAdapter(RuntimeFile.class, new RuntimeFileDeserializer())
+                .create();
+
+        jrePlatformName = findPlatformName(System.getProperty("os.arch").contains("64")); // FIXME: make accurate
+        platformDirectory = runtimesDirectory.resolve(jrePlatformName);
+        executorService = new ExceptionalThreadPoolExecutor(4, 8, 30L, TimeUnit.SECONDS);
+    }
+
+    public void reloadRuntimes() throws IOException {
+        synchronized (refreshingLock) {
+            refreshing = true;
+        }
+
+        manifest = gson.fromJson(Http.performGet(manifestUrl, proxy), new TypeToken<Map<String, Map<String, List<RuntimesManifest.Runtime>>>>(){}.getType());
+
+        LOGGER.info("Your java runtime platform is '" + jrePlatformName + "'.");
+
+        if (!manifest.containsKey(jrePlatformName)) {
+            LOGGER.error("Your JVM platform (" + jrePlatformName + ") is NOT PRESENT in the runtime manifest! The launcher will now break spectacularly.");
+        }
+
+        LOGGER.info("Finished refreshing java runtime list.");
+        synchronized (refreshingLock) {
+            refreshing = false;
+        }
+    }
+
+    public List<RuntimesManifest.Runtime> getRuntimes(String component) {
+        synchronized (refreshingLock) {
+            if (refreshing) return Collections.emptyList();
+        }
+
+        List<RuntimesManifest.Runtime> runtimes = manifest.get(jrePlatformName).get(component);
+        if (runtimes == null) return Collections.emptyList();
+        return Collections.unmodifiableList(runtimes);
+    }
+
+    public boolean shouldDownloadRuntime(String component, RuntimesManifest.Runtime runtime) throws IOException {
+        Path componentFolder = platformDirectory.resolve(component);
+
+        if (!Files.isDirectory(componentFolder)) {
+            return true;
+        }
+
+        Path descPath = componentFolder.resolve(".version");
+        if (Files.notExists(descPath)) return true;
+
+        Instant updateTime;
+        String version;
+
+        try (DataInputStream dis = new DataInputStream(Files.newInputStream(descPath))) {
+            updateTime = Instant.ofEpochMilli(dis.readLong());
+            version = dis.readUTF();
+        }
+
+        return runtime.getVersion().getReleased().isAfter(updateTime) || !runtime.getVersion().getName().equals(version);
+    }
+
+    public Path getJavaExecutable(String component) {
+        Path runtimeDir = platformDirectory.resolve(component).resolve("runtime");
+        OperatingSystem os = OperatingSystem.getCurrentPlatform();
+        if (component.equals("minecraft-java-exe")) {
+            return runtimeDir.resolve("MinecraftJava.exe");
+        } else if (os == OperatingSystem.WINDOWS) {
+            return runtimeDir.resolve("bin").resolve("javaw.exe");
+        } else if (os == OperatingSystem.OSX) {
+            return runtimeDir.resolve("jre.bundle").resolve("Contents").resolve("Home").resolve("bin").resolve("java");
+        } else { // LINUX
+            return runtimeDir.resolve("bin").resolve("java");
+        }
+    }
+
+    public void deleteRuntime(String component) throws IOException {
+        Path componentDir = platformDirectory.resolve(component);
+
+        if (Files.isDirectory(componentDir))
+            Files.walkFileTree(componentDir, DeletingFileVisitor.get());
+    }
+
+    public RuntimeFileList downloadFileList(String component, RuntimesManifest.Runtime runtime) throws IOException {
+        HttpURLConnection conn = (HttpURLConnection)runtime.getManifest().getUrl().openConnection();
+        if (conn.getResponseCode() / 100 != 2) throw new RuntimeException("Error downloading component manifest '" + component + "': Received response " + conn.getResponseCode() + " " + conn.getResponseMessage());
+
+        MessageDigest digest;
+        try {
+            digest = MessageDigest.getInstance("SHA-1");
+        } catch (NoSuchAlgorithmException ex) {
+            throw new RuntimeException(ex); // should not happen
+        }
+
+        RuntimeFileList files;
+        try (Reader reader = new BufferedReader(new InputStreamReader(new DigestInputStream(conn.getInputStream(), digest)))) {
+            files = gson.fromJson(reader, RuntimeFileList.class);
+        }
+
+        String hash = String.format("%1$040x", new BigInteger(1, digest.digest()));
+        if (!hash.equalsIgnoreCase(runtime.getManifest().getSha1()))
+            throw new RuntimeException("Error downloading component manifest '" + component + "': The manifest hash does not match! (Expected " + runtime.getManifest().getSha1() + ", got " + hash + ")");
+        return files;
+    }
+
+    public void preDownloadRuntime(String component, RuntimesManifest.Runtime runtime, RuntimeFileList files) throws IOException {
+        Path componentDir = platformDirectory.resolve(component);
+        Path runtimeRootDir = componentDir.resolve("runtime");
+
+        for (Map.Entry<String, RuntimeFile> entry : files.getFiles().entrySet()) {
+            if (entry.getValue() instanceof RuntimeFileFile) continue;
+            entry.getValue().create(runtimeRootDir.resolve(entry.getKey()));
+        }
+    }
+
+    public void postDownloadRuntime(String component, RuntimesManifest.Runtime runtime) throws IOException {
+        Path componentFolder = platformDirectory.resolve(component);
+        Path objectsFolder = componentFolder.resolve("objects");
+
+        // Write .version
+        Path descPath = componentFolder.resolve(".version");
+        if (Files.notExists(descPath)) {
+            try (DataOutputStream dos = new DataOutputStream(Files.newOutputStream(descPath))) {
+                dos.writeLong(runtime.getVersion().getReleased().toEpochMilli());
+                dos.writeUTF(runtime.getVersion().getName());
+            }
+        }
+
+        // Delete compressed objects
+        if (Files.isDirectory(objectsFolder)) {
+            Files.walkFileTree(objectsFolder, DeletingFileVisitor.get());
+        }
+    }
+
+    public DownloadJob downloadRuntime(DownloadJob job, String component, RuntimeFileList fileList) {
+        RuntimeFileFile file;
+        Path componentFolder = platformDirectory.resolve(component);
+        Path runtimeRoot = componentFolder.resolve("runtime"), objectsRoot = componentFolder.resolve("objects"), path;
+        List<Downloadable> downloadables = new LinkedList<>();
+        for (Map.Entry<String, RuntimeFile> entry : fileList.getFiles().entrySet()) {
+            if (!(entry.getValue() instanceof RuntimeFileFile)) continue;
+            file = (RuntimeFileFile)entry.getValue();
+            path = runtimeRoot.resolve(entry.getKey());
+            if (file.getRaw() == null) {
+                LOGGER.warn(entry.getKey() + " AAAAAAAAa");
+            }
+            downloadables.add(new RuntimeFileDownloadable(proxy, entry.getKey(), objectsRoot, path, file));
+        }
+        job.addDownloadables(downloadables);
+        return job;
+    }
+
+    private static String findPlatformName(boolean _64bit) {
+        switch (OperatingSystem.getCurrentPlatform()) {
+            case WINDOWS:
+                return _64bit ? "windows-x64" : "windows-x86";
+            case OSX:
+                return "mac-os";
+            case LINUX:
+                return _64bit ? "linux" : "linux-i386"; // not technically correct
+            default:
+                return "gamecore";
+        }
+    }
+}
diff --git a/src/main/java/dev/figboot/olauncher/launcher/runtime/RuntimesManifest.java b/src/main/java/dev/figboot/olauncher/launcher/runtime/RuntimesManifest.java
new file mode 100644
index 0000000..70a802a
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/launcher/runtime/RuntimesManifest.java
@@ -0,0 +1,20 @@
+package dev.figboot.olauncher.launcher.runtime;
+
+import lombok.Getter;
+import net.minecraft.launcher.updater.DownloadInfo;
+
+import java.time.Instant;
+
+public final class RuntimesManifest {
+    private RuntimesManifest() { }
+
+    public static class Runtime {
+        @Getter private DownloadInfo manifest;
+        @Getter private Version version;
+    }
+
+    public static class Version {
+        @Getter private String name;
+        @Getter private Instant released;
+    }
+}
diff --git a/src/main/java/dev/figboot/olauncher/launcher/runtime/download/RuntimeFileDownloadable.java b/src/main/java/dev/figboot/olauncher/launcher/runtime/download/RuntimeFileDownloadable.java
new file mode 100644
index 0000000..bd60459
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/launcher/runtime/download/RuntimeFileDownloadable.java
@@ -0,0 +1,200 @@
+package dev.figboot.olauncher.launcher.runtime.download;
+
+import com.mojang.launcher.updater.download.Downloadable;
+import com.mojang.launcher.updater.download.MonitoringInputStream;
+import dev.figboot.olauncher.launcher.runtime.file.RuntimeFileFile;
+import lombok.RequiredArgsConstructor;
+import org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.math.BigInteger;
+import java.net.HttpURLConnection;
+import java.net.Proxy;
+import java.net.URL;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.attribute.PosixFilePermission;
+import java.security.DigestInputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.HashSet;
+import java.util.Set;
+
+// Adapted from AssetDownloadable
+public class RuntimeFileDownloadable extends Downloadable {
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    private final String name;
+    private final RuntimeFileFile file;
+    private final Path objectLoc, finalLoc;
+    private Status status;
+
+    public RuntimeFileDownloadable(Proxy proxy, String name, Path objectsDir, Path finalLoc, RuntimeFileFile file) {
+        super(proxy, file.getRaw().getUrl(), finalLoc.toFile(), false);
+        this.name = name;
+        objectLoc = file.getLzma() != null ? resolvePathFromHash(objectsDir, file.getLzma().getSha1()) : null;
+        this.finalLoc = finalLoc;
+        this.file = file;
+        status = Status.DOWNLOADING;
+    }
+
+    private Path resolvePathFromHash(Path p, String hash) {
+        return p.resolve(hash.substring(0, 2)).resolve(hash);
+    }
+
+    @Override
+    public String download() throws IOException {
+        ++this.numAttempts;
+
+        ensureFileWritable(finalLoc);
+        if (objectLoc != null) ensureFileWritable(objectLoc);
+
+        if (Files.isRegularFile(finalLoc)) {
+            long size = Files.size(finalLoc);
+            if (size == file.getRaw().getSize()) {
+                setExecutable(finalLoc);
+                return "Have local file and it's the correct size. Assuming it's okay!";
+            }
+
+            LOGGER.warn("Have local file, but it has the wrong size: {} expected, got {}", new Object[]{file.getRaw().getSize(), size});
+            Files.delete(finalLoc);
+            status = Status.DOWNLOADING;
+        }
+
+        if (objectLoc != null && Files.isRegularFile(objectLoc)) {
+            String hash = getDigest(objectLoc, "SHA-1", 40);
+            if (hash.equalsIgnoreCase(file.getLzma().getSha1())) {
+                return decompress();
+            }
+
+            LOGGER.warn("Have local compressed file, but it has the wrong hash: {} expected, got {}", new Object[]{file.getLzma().getSha1(), hash});
+            Files.delete(objectLoc);
+        }
+
+        if (objectLoc != null) { // download compressed :)
+            String hash = actuallyDownload(file.getLzma().getUrl(), objectLoc);
+
+            if (hash.equalsIgnoreCase(file.getLzma().getSha1())) {
+                return decompress();
+            }
+
+            Files.delete(objectLoc);
+            throw new RuntimeException(String.format("Hash does not match for downloaded compressed file. %s expected, got %s", file.getLzma().getSha1(), hash));
+        } else { // download raw :(
+            String hash = actuallyDownload(file.getRaw().getUrl(), finalLoc);
+
+            if (hash.equalsIgnoreCase(file.getRaw().getSha1())) {
+                setExecutable(finalLoc);
+                return "File downloaded and hash matched.";
+            }
+
+            Files.delete(finalLoc);
+            throw new RuntimeException(String.format("Hash does not match for downloaded file. %s expected, got %s", file.getRaw().getSha1(), hash));
+        }
+    }
+
+    @Override
+    public String getStatus() {
+        return status.name + " " + name;
+    }
+
+    private String actuallyDownload(URL url, Path target) throws IOException {
+        HttpURLConnection conn = makeConnection(url);
+        int res = conn.getResponseCode();
+        if (res / 100 != 2) {
+            throw new RuntimeException("Server responded with " + res + " " + conn.getResponseMessage());
+        }
+
+        updateExpectedSize(conn);
+        String hash;
+        try (InputStream is = new MonitoringInputStream(conn.getInputStream(), getMonitor());
+             OutputStream os = Files.newOutputStream(target)) {
+            hash = copyAndDigest(is, os, "SHA-1", 40);
+        }
+        return hash;
+    }
+
+    private void setExecutable(Path path) throws IOException {
+        if (!file.isExecutable()) return;
+
+        try {
+            Set<PosixFilePermission> permission = new HashSet<>(Files.getPosixFilePermissions(path));
+            permission.add(PosixFilePermission.OWNER_EXECUTE);
+            permission.add(PosixFilePermission.GROUP_EXECUTE);
+            permission.add(PosixFilePermission.OTHERS_EXECUTE);
+            Files.setPosixFilePermissions(path, permission);
+        } catch (UnsupportedOperationException ex) {
+            LOGGER.info("Not setting " + path.toString() + " executable, the filesystem does not support it.");
+        }
+    }
+
+    private String decompress() throws IOException {
+        status = Status.DECOMPRESSING;
+
+        String hash;
+        try (OutputStream os = Files.newOutputStream(finalLoc);
+                InputStream is = new LZMACompressorInputStream(Files.newInputStream(objectLoc))) {
+            hash = copyAndDigest(is, os, "SHA-1", 40);
+        }
+
+        status = Status.DOWNLOADING;
+        if (hash.equalsIgnoreCase(file.getRaw().getSha1())) {
+            setExecutable(finalLoc);
+            return "Decompressed file and hash matched";
+        } else {
+            Files.delete(finalLoc);
+            throw new RuntimeException(String.format("Decompressed file hash did not match! %s expected, got %s", file.getRaw().getSha1(), hash));
+        }
+    }
+
+    private void ensureFileWritable(Path path) throws IOException {
+        Path parent = path.getParent();
+        if (parent != null && !Files.isDirectory(parent)) {
+            LOGGER.info("Making directory " + parent);
+            Files.createDirectories(parent);
+        }
+
+        if (Files.isRegularFile(path) && !Files.isWritable(path)) {
+            throw new RuntimeException("Do not have write permissions for " + path + " - aborting!");
+        }
+    }
+
+    private String getDigest(Path path, String digest, int padChars) throws IOException {
+        MessageDigest md;
+        try {
+            md = MessageDigest.getInstance(digest);
+        } catch (NoSuchAlgorithmException ex) {
+            throw new RuntimeException(ex);
+        }
+
+        try (InputStream is = new DigestInputStream(Files.newInputStream(path), md)) {
+            byte[] buf = new byte[65536];
+            int numread;
+            do {
+                numread = is.read(buf);
+            } while (numread > 0);
+        }
+
+        return String.format("%1$0" + padChars + "x", new BigInteger(1, md.digest()));
+    }
+
+    private static MessageDigest getSha1Digest() {
+        try {
+            return MessageDigest.getInstance("SHA-1");
+        } catch (NoSuchAlgorithmException ex) {
+            throw new RuntimeException(ex); // propagate
+        }
+    }
+
+    @RequiredArgsConstructor
+    private enum Status {
+        DOWNLOADING("Downloading"),
+        DECOMPRESSING("Decompressing");
+
+        private final String name;
+    }
+}
diff --git a/src/main/java/dev/figboot/olauncher/launcher/runtime/file/RuntimeFile.java b/src/main/java/dev/figboot/olauncher/launcher/runtime/file/RuntimeFile.java
new file mode 100644
index 0000000..6722616
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/launcher/runtime/file/RuntimeFile.java
@@ -0,0 +1,8 @@
+package dev.figboot.olauncher.launcher.runtime.file;
+
+import java.io.IOException;
+import java.nio.file.Path;
+
+public interface RuntimeFile {
+    void create(Path path) throws IOException;
+}
diff --git a/src/main/java/dev/figboot/olauncher/launcher/runtime/file/RuntimeFileDirectory.java b/src/main/java/dev/figboot/olauncher/launcher/runtime/file/RuntimeFileDirectory.java
new file mode 100644
index 0000000..1cc3710
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/launcher/runtime/file/RuntimeFileDirectory.java
@@ -0,0 +1,12 @@
+package dev.figboot.olauncher.launcher.runtime.file;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+public class RuntimeFileDirectory implements RuntimeFile {
+    @Override
+    public void create(Path path) throws IOException {
+        Files.createDirectories(path);
+    }
+}
diff --git a/src/main/java/dev/figboot/olauncher/launcher/runtime/file/RuntimeFileFile.java b/src/main/java/dev/figboot/olauncher/launcher/runtime/file/RuntimeFileFile.java
new file mode 100644
index 0000000..b2547d6
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/launcher/runtime/file/RuntimeFileFile.java
@@ -0,0 +1,26 @@
+package dev.figboot.olauncher.launcher.runtime.file;
+
+import lombok.Getter;
+import net.minecraft.launcher.updater.DownloadInfo;
+
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.Map;
+
+public class RuntimeFileFile implements RuntimeFile {
+    @Getter private boolean executable;
+    @Getter private Map<String, DownloadInfo> downloads;
+
+    @Override
+    public void create(Path path) throws IOException {
+        throw new UnsupportedOperationException("The file must be downloaded");
+    }
+
+    public DownloadInfo getRaw() {
+        return downloads.get("raw");
+    }
+
+    public DownloadInfo getLzma() {
+        return downloads.get("lzma");
+    }
+}
diff --git a/src/main/java/dev/figboot/olauncher/launcher/runtime/file/RuntimeFileLink.java b/src/main/java/dev/figboot/olauncher/launcher/runtime/file/RuntimeFileLink.java
new file mode 100644
index 0000000..4d0d9a9
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/launcher/runtime/file/RuntimeFileLink.java
@@ -0,0 +1,17 @@
+package dev.figboot.olauncher.launcher.runtime.file;
+
+import lombok.Getter;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+public class RuntimeFileLink implements RuntimeFile {
+    @Getter private String target;
+
+    @Override
+    public void create(Path path) throws IOException {
+        Files.createSymbolicLink(path, Paths.get(target));
+    }
+}
diff --git a/src/main/java/dev/figboot/olauncher/launcher/runtime/file/RuntimeFileList.java b/src/main/java/dev/figboot/olauncher/launcher/runtime/file/RuntimeFileList.java
new file mode 100644
index 0000000..1fbaa33
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/launcher/runtime/file/RuntimeFileList.java
@@ -0,0 +1,9 @@
+package dev.figboot.olauncher.launcher.runtime.file;
+
+import lombok.Getter;
+
+import java.util.Map;
+
+public class RuntimeFileList {
+    @Getter private Map<String, RuntimeFile> files;
+}
diff --git a/src/main/java/dev/figboot/olauncher/util/DeletingFileVisitor.java b/src/main/java/dev/figboot/olauncher/util/DeletingFileVisitor.java
new file mode 100644
index 0000000..48d6a04
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/util/DeletingFileVisitor.java
@@ -0,0 +1,41 @@
+package dev.figboot.olauncher.util;
+
+import java.io.IOException;
+import java.nio.file.FileVisitResult;
+import java.nio.file.FileVisitor;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.attribute.BasicFileAttributes;
+
+public class DeletingFileVisitor implements FileVisitor<Path> {
+    private static final DeletingFileVisitor INSTANCE = new DeletingFileVisitor();
+
+    public static DeletingFileVisitor get() {
+        return INSTANCE;
+    }
+
+    private DeletingFileVisitor() { }
+
+    @Override
+    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
+        return FileVisitResult.CONTINUE;
+    }
+
+    @Override
+    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
+        Files.delete(file);
+        return FileVisitResult.CONTINUE;
+    }
+
+    @Override
+    public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
+        throw exc;
+    }
+
+    @Override
+    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
+        if (exc != null) throw exc;
+        Files.delete(dir);
+        return FileVisitResult.CONTINUE;
+    }
+}
diff --git a/src/main/java/dev/figboot/olauncher/util/runtime/RuntimeFileDeserializer.java b/src/main/java/dev/figboot/olauncher/util/runtime/RuntimeFileDeserializer.java
new file mode 100644
index 0000000..18c77f3
--- /dev/null
+++ b/src/main/java/dev/figboot/olauncher/util/runtime/RuntimeFileDeserializer.java
@@ -0,0 +1,28 @@
+package dev.figboot.olauncher.util.runtime;
+
+import com.google.gson.*;
+import dev.figboot.olauncher.launcher.runtime.file.RuntimeFile;
+import dev.figboot.olauncher.launcher.runtime.file.RuntimeFileDirectory;
+import dev.figboot.olauncher.launcher.runtime.file.RuntimeFileFile;
+import dev.figboot.olauncher.launcher.runtime.file.RuntimeFileLink;
+
+import java.lang.reflect.Type;
+
+public class RuntimeFileDeserializer implements JsonDeserializer<RuntimeFile> {
+    @Override
+    public RuntimeFile deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
+        JsonObject obj = json.getAsJsonObject();
+        String type = obj.get("type").getAsString();
+
+        switch (type) {
+            case "file":
+                return context.deserialize(obj, RuntimeFileFile.class);
+            case "directory":
+                return context.deserialize(obj, RuntimeFileDirectory.class);
+            case "link":
+                return context.deserialize(obj, RuntimeFileLink.class);
+        }
+
+        throw new JsonParseException("Unknown file type '" + type + "'");
+    }
+}
diff --git a/src/main/java/net/minecraft/launcher/Launcher.java b/src/main/java/net/minecraft/launcher/Launcher.java
index a9a6ee3..1ed2f8f 100644
--- a/src/main/java/net/minecraft/launcher/Launcher.java
+++ b/src/main/java/net/minecraft/launcher/Launcher.java
@@ -31,11 +31,15 @@ import java.util.List;
 import java.util.Locale;
 import java.util.UUID;
 import javax.swing.JFrame;
+
+import dev.figboot.olauncher.OLauncherConstants;
+import dev.figboot.olauncher.launcher.runtime.JavaRuntimeManager;
 import joptsimple.ArgumentAcceptingOptionSpec;
 import joptsimple.NonOptionArgumentSpec;
 import joptsimple.OptionException;
 import joptsimple.OptionParser;
 import joptsimple.OptionSet;
+import lombok.Getter;
 import net.minecraft.launcher.game.GameLaunchDispatcher;
 import net.minecraft.launcher.game.MinecraftReleaseType;
 import net.minecraft.launcher.game.MinecraftReleaseTypeFactory;
@@ -110,6 +114,7 @@ public class Launcher {
             this.launcher = new com.mojang.launcher.Launcher(this.userInterface, var2, var3, var4, new MinecraftVersionManager(new LocalVersionList(var2), new RemoteVersionList(LauncherConstants.PROPERTIES.getVersionManifest(), var3)), Agent.MINECRAFT, MinecraftReleaseTypeFactory.instance(), 21);
             this.profileManager = new ProfileManager(this);
             ((SwingUserInterface)this.userInterface).initializeFrame();
+            refreshJavaRuntimes(); // olauncher - refresh java runtimes
             this.refreshVersionsAndProfiles();
         }
     }
@@ -171,6 +176,18 @@ public class Launcher {
         return (String[])var6.toArray(new String[var6.size()]);
     }
 
+    // olauncher start - refresh java runtime function
+    public void refreshJavaRuntimes() {
+        getLauncher().getJreManager().getExecutorService().submit(() -> {
+            try {
+                getLauncher().getJreManager().reloadRuntimes();
+            } catch (Throwable t) {
+                Launcher.LOGGER.error("Unexpected exception refreshing java runtime list", t);
+            }
+        });
+    }
+    // olauncher end
+
     public void refreshVersionsAndProfiles() {
         this.getLauncher().getVersionManager().getExecutorService().submit(new Runnable() {
             public void run() {
diff --git a/src/main/java/net/minecraft/launcher/SwingUserInterface.java b/src/main/java/net/minecraft/launcher/SwingUserInterface.java
index 06e506a..12b5f87 100644
--- a/src/main/java/net/minecraft/launcher/SwingUserInterface.java
+++ b/src/main/java/net/minecraft/launcher/SwingUserInterface.java
@@ -103,10 +103,12 @@ public class SwingUserInterface implements MinecraftUserInterface {
                 SwingUserInterface.this.frame.dispose();
                 SwingUserInterface.LOGGER.info("Halting executors");
                 SwingUserInterface.this.minecraftLauncher.getLauncher().getVersionManager().getExecutorService().shutdown();
+                SwingUserInterface.this.minecraftLauncher.getLauncher().getJreManager().getExecutorService().shutdown(); // olauncher - shut down jreManager executor
                 SwingUserInterface.LOGGER.info("Awaiting termination.");
 
                 try {
                     SwingUserInterface.this.minecraftLauncher.getLauncher().getVersionManager().getExecutorService().awaitTermination(10L, TimeUnit.SECONDS);
+                    SwingUserInterface.this.minecraftLauncher.getLauncher().getJreManager().getExecutorService().awaitTermination(10L, TimeUnit.SECONDS); // olauncher - wait for jreManager executor to stop
                 } catch (InterruptedException var3) {
                     SwingUserInterface.LOGGER.info("Termination took too long.");
                 }
diff --git a/src/main/java/net/minecraft/launcher/game/GameLaunchDispatcher.java b/src/main/java/net/minecraft/launcher/game/GameLaunchDispatcher.java
index a4b4e50..4349e7d 100644
--- a/src/main/java/net/minecraft/launcher/game/GameLaunchDispatcher.java
+++ b/src/main/java/net/minecraft/launcher/game/GameLaunchDispatcher.java
@@ -119,7 +119,7 @@ public class GameLaunchDispatcher implements GameRunnerListener {
 
                 var5.setStatus(GameInstanceStatus.IDLE);
                 var5.addListener(GameLaunchDispatcher.this);
-                var5.playGame(var1);
+                var5.playGame(var1, var2.getJavaPath() == null); // olauncher - add bundledRuntime argument
             }
         });
     }
diff --git a/src/main/java/net/minecraft/launcher/game/MinecraftGameRunner.java b/src/main/java/net/minecraft/launcher/game/MinecraftGameRunner.java
index 6f7050d..bc607d1 100644
--- a/src/main/java/net/minecraft/launcher/game/MinecraftGameRunner.java
+++ b/src/main/java/net/minecraft/launcher/game/MinecraftGameRunner.java
@@ -34,6 +34,8 @@ import java.io.InputStreamReader;
 import java.net.InetSocketAddress;
 import java.net.PasswordAuthentication;
 import java.net.Proxy;
+import java.nio.file.Files;
+import java.nio.file.Path;
 import java.util.Collection;
 import java.util.Date;
 import java.util.Enumeration;
@@ -47,6 +49,7 @@ import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
 import dev.figboot.olauncher.auth.MicrosoftUserAuthentication;
+import dev.figboot.olauncher.launcher.runtime.RuntimesManifest;
 import net.minecraft.launcher.CompatibilityRule;
 import net.minecraft.launcher.CurrentLaunchFeatureMatcher;
 import net.minecraft.launcher.Launcher;
@@ -157,7 +160,15 @@ public class MinecraftGameRunner extends AbstractGameRunner implements GameProce
                 var3.mkdirs();
             }
 
-            GameProcessBuilder var4 = new GameProcessBuilder((String)MoreObjects.firstNonNull(this.selectedProfile.getJavaPath(), OperatingSystem.getCurrentPlatform().getJavaDir())); // olauncher - Objects -> MoreObjects
+            // olauncher start - pick the java path
+            String javaPath = this.selectedProfile.getJavaPath();
+            Path bundledDir = getBundledRuntimeDir();
+            if (javaPath == null || bundledDir != null) {
+                javaPath = bundledDir.toAbsolutePath().toString();
+            }
+            // olauncher end
+
+            GameProcessBuilder var4 = new GameProcessBuilder((String)MoreObjects.firstNonNull(javaPath, OperatingSystem.getCurrentPlatform().getJavaDir())); // olauncher - add bundled runtimes // olauncher - Objects -> MoreObjects
             var4.withSysOutFilter(new Predicate<String>() {
                 public boolean apply(String var1) {
                     return var1.contains("#@!@#");
diff --git a/src/main/java/net/minecraft/launcher/ui/popups/profile/ProfileJavaPanel.java b/src/main/java/net/minecraft/launcher/ui/popups/profile/ProfileJavaPanel.java
index e510a79..c752284 100644
--- a/src/main/java/net/minecraft/launcher/ui/popups/profile/ProfileJavaPanel.java
+++ b/src/main/java/net/minecraft/launcher/ui/popups/profile/ProfileJavaPanel.java
@@ -22,6 +22,8 @@ public class ProfileJavaPanel extends JPanel {
     private final JCheckBox javaArgsCustom = new JCheckBox("JVM Arguments:");
     private final JTextField javaArgsField = new JTextField();
 
+    private String javaPath; // olauncher - bundled java runtime UI
+
     public ProfileJavaPanel(ProfileEditorPopup var1) {
         this.editor = var1;
         this.setLayout(new GridBagLayout());
@@ -29,6 +31,8 @@ public class ProfileJavaPanel extends JPanel {
         this.createInterface();
         this.fillDefaultValues();
         this.addEventHandlers();
+
+        javaPath = OperatingSystem.getCurrentPlatform().getJavaDir();
     }
 
     protected void createInterface() {
@@ -55,11 +59,13 @@ public class ProfileJavaPanel extends JPanel {
     protected void fillDefaultValues() {
         String var1 = this.editor.getProfile().getJavaPath();
         if (var1 != null) {
+            javaPath = var1;
             this.javaPathCustom.setSelected(true);
             this.javaPathField.setText(var1);
         } else {
             this.javaPathCustom.setSelected(false);
-            this.javaPathField.setText(OperatingSystem.getCurrentPlatform().getJavaDir());
+            //this.javaPathField.setText(OperatingSystem.getCurrentPlatform().getJavaDir()); // olauncher - bundled java runtime UI
+            this.javaPathField.setText("Use bundled runtime");
         }
 
         this.updateJavaPathState();
@@ -126,9 +132,12 @@ public class ProfileJavaPanel extends JPanel {
     private void updateJavaPathState() {
         if (this.javaPathCustom.isSelected()) {
             this.javaPathField.setEnabled(true);
-            this.editor.getProfile().setJavaDir(this.javaPathField.getText());
+            this.javaPathField.setText(javaPath);
+            this.editor.getProfile().setJavaDir(javaPath);
         } else {
             this.javaPathField.setEnabled(false);
+            javaPath = javaPathField.getText();
+            javaPathField.setText("Use bundled runtime");
             this.editor.getProfile().setJavaDir((String)null);
         }
 
diff --git a/src/main/java/net/minecraft/launcher/updater/CompleteMinecraftVersion.java b/src/main/java/net/minecraft/launcher/updater/CompleteMinecraftVersion.java
index 9d786d5..53ee706 100644
--- a/src/main/java/net/minecraft/launcher/updater/CompleteMinecraftVersion.java
+++ b/src/main/java/net/minecraft/launcher/updater/CompleteMinecraftVersion.java
@@ -25,6 +25,9 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.Map.Entry;
+
+import dev.figboot.olauncher.launcher.JavaVersionInfo;
+import lombok.Getter;
 import net.minecraft.launcher.CompatibilityRule;
 import net.minecraft.launcher.CurrentLaunchFeatureMatcher;
 import net.minecraft.launcher.Launcher;
@@ -54,6 +57,8 @@ public class CompleteMinecraftVersion implements CompleteVersion {
     private AssetIndexInfo assetIndex;
     private Map<ArgumentType, List<Argument>> arguments;
 
+    private JavaVersionInfo javaVersion; // olauncher - add java version
+
     public CompleteMinecraftVersion() {
     }
 
@@ -105,6 +110,8 @@ public class CompleteMinecraftVersion implements CompleteVersion {
             }
         }
 
+        // olauncher - handle java version
+        if (var1.javaVersion != null) this.javaVersion = new JavaVersionInfo(var1.javaVersion);
     }
 
     public String getId() {
@@ -362,6 +369,9 @@ public class CompleteMinecraftVersion implements CompleteVersion {
                 }
             }
 
+            // olauncher - handle java version
+            if (this.javaVersion != null) var5.javaVersion = new JavaVersionInfo(this.javaVersion);
+
             return var5;
         }
     }
@@ -435,4 +445,10 @@ public class CompleteMinecraftVersion implements CompleteVersion {
         }
 
     }
+
+    // olauncher start - add java version info getter
+    public JavaVersionInfo getJavaVersion() {
+        return javaVersion == null ? JavaVersionInfo.DEFAULT : javaVersion;
+    }
+    // olauncher end
 }
-- 
2.47.2

